# -*- coding: utf-8 -*-
"""최종_시연.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HO44mLgTGqPiZcLGu_zOIMRaHOcZgvyv

구글 드라이브와 연동
"""

# 구글 드라이브와 연동 
from google.colab import drive
drive.mount('/content/gdrive') 
#directory_path = '/content/gdrive/My Drive/Colab Notebooks/'
directory_path = '/content/gdrive/My Drive/Colab Notebooks/따릉이타조'   #이서린
# 구글 드라이브 directory_path 위치에 따릉이 데이터 csv 파일 저장

"""사용할 도구 가져오기"""

!pip install folium

import pandas as pd
import numpy as np
import plotly.express as px
import matplotlib.pyplot as plt
import folium
from folium.plugins import MarkerCluster, MiniMap
from tqdm import tqdm

"""기본 글꼴 변경"""

# 폰트 설치 
!sudo apt-get install -y fonts-nanum
!sudo fc-cache -fv
!rm ~/.cache/matplotlib -rf

import matplotlib as mpl
'''
mpl.font_manager._rebuild()
'''
mpl.pyplot.rc('font', family='NanumBarunGothic')

"""데이터 불러오기"""

import csv

#데이터 불러오기
#directory_path = '/content/gdrive/My Drive/Colab Notebooks/'
directory_path = '/content/gdrive/My Drive/Colab Notebooks/따릉이타조'   #이서린

# 서울시 공공자전거 대여소 정보
# 수정한 데이터로 변경
df_location = pd.read_csv(directory_path + '공공자전거 대여소 정보(21.01.31 기준).csv', encoding='cp949')

# 공공자전거 대여이력 정보
# 2020년
df_2020_01 = pd.read_csv(directory_path + '공공자전거 대여이력 정보_2020.01.csv', encoding='cp949')
df_2020_02 = pd.read_csv(directory_path + '공공자전거 대여이력 정보_2020.02.csv', encoding='cp949')
df_2020_03 = pd.read_csv(directory_path + '공공자전거 대여이력 정보_2020.03.csv', encoding='cp949')
df_2020_04 = pd.read_csv(directory_path + '공공자전거 대여이력 정보_2020.04.csv', encoding='cp949')
df_2020_05 = pd.read_csv(directory_path + '공공자전거 대여이력 정보_2020.05.csv', encoding='cp949')
df_2020_06 = pd.read_csv(directory_path + '공공자전거 대여이력 정보_2020.06.csv', encoding='cp949')
df_2020_07_08 = pd.read_csv(directory_path + '공공자전거 대여이력 정보_2020.07_08.csv', encoding='cp949')
df_2020_09 = pd.read_csv(directory_path + '공공자전거 대여이력 정보_2020.09.csv', encoding='cp949')
df_2020_10 = pd.read_csv(directory_path + '공공자전거 대여이력 정보_2020.10.csv', encoding='cp949')
df_2020_11 = pd.read_csv(directory_path + '공공자전거 대여이력 정보_2020.11.csv', encoding='cp949')
df_2020_12 = pd.read_csv(directory_path + '공공자전거 대여이력 정보_2020.12.csv', encoding='cp949')

"""공공자전거 대여이력 정보 데이터 합치기"""

# 2020년
df_2020 = pd.concat([df_2020_01, df_2020_02, df_2020_03, df_2020_04, df_2020_05, df_2020_06, df_2020_07_08, df_2020_09, df_2020_10, df_2020_11, df_2020_12], join='outer')

"""공공자전거 대여소 정보 데이터처리"""

# 공공자전거 대여소 정보 데이터 처리: NaN 값 처리

for i in range(0,4) :
  df_location_proc = df_location.drop(df_location.index[0]) # 0,1,2,3행 제거
  df_location = df_location_proc

df_location_processed=df_location_proc.fillna(0) # 0,1,2,3행을 제외한 거치대수 결측치는 0으로 나오도록 함.
df_location_processed.head(10)

"""2020 대여이력 데이터 처리"""

# 공공자전거 대여이력 정보 중 2020년 데이터가 아닌 경우 삭제
# df_2020[df_2020['대여일시']>="2020-12-31 23:59"]
index_b_false = df_2020[(df_2020['반납일시']>="2020-12-31 23:59")|(df_2020['반납일시']<="2020-01-01 00:00")].index
df_2020_processed = df_2020.drop(index_b_false)

"""현재 날짜, 시간 구하기"""

#현재 날짜, 시간 구하기
from pytz import timezone
import datetime

KST = timezone('Asia/Seoul')

'''utcnow= datetime.datetime.utcnow()
time_gap= datetime.timedelta(hours=9)
kor_time= utcnow+ time_gap'''

now = datetime.datetime.now(KST)
print(now)

# 날짜 구하기
nowDate = now.date()
print(nowDate)

# 년, 월, 일 구하기
nowYear = now.year
nowMonth = now.month
nowDay = now.day
print(nowYear)
print(nowMonth)
print(nowDay)

# 시간 구하기
nowTime = now.time()
print(nowTime)

# 시 구하기
nowHour = now.hour
print(nowHour)

# 분 구하기
nowMinute = now.minute
print(nowMinute)

# 요일 구하기
days = ['월요일','화요일', '수요일', '목요일','금요일', '토요일','일요일']
nowWeekday_index = now.weekday()
nowWeekday = days[nowWeekday_index]
print(nowWeekday)

"""2020 대여이력 대여/반납 연, 월, 일, 요일, 시, 분 표시되도록 데이터셋 가공"""

from datetime import datetime # datetime 함수 object형을 날짜/시간으로 변환

borrow_day_time = pd.to_datetime(df_2020_processed['대여일시']) # 대여일시 날짜/시간으로 변환하여 저장
return_day_time = pd.to_datetime(df_2020_processed['반납일시']) # 반납일시 날짜/시간으로 변환하여 저장

df_2020_processed['연도']= borrow_day_time.dt.year # 대여일시 연도 데이터에 추가
df_2020_processed['월(대여)']= borrow_day_time.dt.month # 대여일시 월 데이터에 추가
df_2020_processed['일(대여)']= borrow_day_time.dt.day # 대여일시 일 데이터에 추가
df_2020_processed['월(반납)']= return_day_time.dt.month # 대여일시 월 데이터에 추가
df_2020_processed['일(반납)']= return_day_time.dt.day # 대여일시 일 데이터에 추가

wday={0:'월',1:'화',2:'수',3:'목',4:'금',5:'토',6:'일'}

df_2020_processed['대여요일'] = borrow_day_time.dt.dayofweek.map(wday) # 대여일시 요일 데이터에 추가
df_2020_processed['반납요일']= return_day_time.dt.dayofweek.map(wday) # 반납일시 요일 데이터에 추가
df_2020_processed['대여시']= borrow_day_time.dt.hour # 대여일시 시 데이터에 추가
df_2020_processed['대여분']= borrow_day_time.dt.minute # 대여일시 분 데이터에 추가
df_2020_processed['반납시']= return_day_time.dt.hour # 반납일시 시 데이터에 추가
df_2020_processed['반납분']= return_day_time.dt.minute # 반납일시 분 데이터에 추가

df_2020_processed.head(5)

"""---
**함수 구현**

**사용자가 위치한 구, 동, 길(로) 입력받기: def input_gudongro()**
"""

def input_gudongro():
  # 전역변수 선언
  global gu
  global dong
  global ro

  userloca=str(input("현재 위치하신 지역의 구, 동, 길(로) 단위를 입력하세요(예: 종로구, 명동, 명동대로) : "))
  userloca_1=list(map(str,userloca.split(', ')))
  gu=(userloca_1[0])
  dong=(userloca_1[1])
  ro=(userloca_1[2])

"""**초기 지도 출력: def initial_map**"""

def initial_map():
  # 전역변수 선언
  global detailloca
  global loca_gu

  # 자치구 먼저 구분, 위도 경도 데이터 삭제
  samegu=df_location_processed['자치구']==gu
  loca_gu_ori=df_location_processed[samegu]
  ok_lati=loca_gu_ori['위도']!=0
  ok_long=loca_gu_ori['경도']!=0
  loca_gu=loca_gu_ori[ok_long & ok_lati]

  # 동, 길 중 하나 이상 일치하는 정류소를 담은 리스트 detailloca
  detailloca=[]

  for i in loca_gu['상세주소']:
    if dong in i or ro in i:
      detailloca.append(i)

  # detailloca 리스트의 첫 번째 데이터 기준으로 함
  refer=loca_gu['상세주소']==detailloca[0]
  refer2=loca_gu[refer]
  lati=refer2['위도']
  longi=refer2['경도']
  latitude_1=float(lati)
  longitude_1=float(longi)
  print(longitude_1,latitude_1)

  map_dt=folium.Map(location=[latitude_1,longitude_1], zoom_start = 19) 
  mc=MarkerCluster()
  names=list(df_location_processed['보관소(대여소)명'])
  latitudes = list(df_location_processed['위도'])
  longitudes =list( df_location_processed['경도'])
  m = "n분 후 n개"  #평균 값을 집어넣기
  for i in tqdm(range(len(names))):
    mc.add_child(folium.Marker(location = [latitudes[i], longitudes[i]], popup=names[i], tooltip=m))
    map_dt.add_child(mc)
  return map_dt

"""**사용자에게 정확한 대여소명 입력받기: def input_name()**"""

def input_name():
  # 전역변수 선언
  global bike_stop
  global borrow_loc

  name=[]
  for a in range(len(detailloca)):
    addcomp=loca_gu['상세주소']==detailloca[a]
    A=loca_gu[addcomp]
    for i in A['보관소(대여소)명']:
      name.append(i)
 
  name_set=set(name) #집합set으로 변환
  detailname=list(name_set) #list로 변환
  detailname

  #지도를 먼저 보여주고, 리스트 출력해서 사용자가 확인하도록 하기
  #사용자에게 입력받기(가까운 정류장 선택하도록 하기) if 조건으로 인덱스 개수 먼저 확인
  print('가까운 정류소의 목록입니다.\n')
  print("====================================================================")
  if len(detailloca) >5:
    for i in range(len(detailloca)):
      print('%d. %s (%s)'%(i+1,detailname[i],detailloca[i]))
    print("====================================================================")
    bike_stop=int(input('\n위 목록 중 가장 가까운 정류장의 번호를 고르세요: '))

  else:
    bike_stop = 0
    print("====================================================================")
  print("\n선택하신 정류장은 %s(%s) 입니다."%(detailname[bike_stop-1],detailloca[bike_stop-1]))

  userpick=loca_gu['상세주소']==detailloca[bike_stop-1]
  first_stop=loca_gu[userpick]
  first_stop

  borrow_loc = detailname[bike_stop-1]

"""**공휴일인지 판단하는 함수: def find_holiday()**

- 공통 공휴일

 - 1/1 : 신정

 - 3/1 : 삼일절

 - 5/5 : 어린이날

 - 6/6 : 현충일

 - 8/15 : 광복절

 - 10/3 : 개천절

 - 10/9 : 한글날

 - 12/25 : 크리스마스

- 2020년 공휴일

 - 1/24~1/26 : 설날

 - 1/27 : 대체공휴일

 - 4/15 : 제21대 국회의원선거

 - 4/30 : 부처님오신날

 - 9/30~10/2 : 추석

- 2021년 공휴일

 - 2/11~2/13 : 설날

 - 5/19 : 부처님오신날

 - 9/20~9/22 : 추석

 => **2020년 데이터를 활용하여 예측할 날짜: 공통 공휴일 + 2021년 공휴일**
"""

def find_holiday():
  global finder
  finder=0 # finder: 공휴일인지 판단하는 값 -> 공휴일이라면 finder=1, 공휴일이 아니라면 finder=0

  #현재 날짜, 시간 구하기
  from pytz import timezone
  import datetime

  KST = timezone('Asia/Seoul')

  now = datetime.datetime.now(KST)

  # 날짜 구하기
  nowDate = now.date()

  # 년, 월, 일 구하기
  nowYear = now.year
  nowMonth = now.month
  nowDay = now.day

  # 공휴일인지 판단
  # 공통 공휴일
  if (nowMonth==1) & (nowDay==1):
    finder=1
  elif (nowMonth==3) & (nowDay==1):
    finder=1
  elif (nowMonth==5) & (nowDay==5):
    finder=1
  elif (nowMonth==6) & (nowDay==6):
    finder=1
  elif (nowMonth==8) & (nowDay==15):
    finder=1
  elif (nowMonth==10) & (nowDay==3):
    finder=1
  elif (nowMonth==10) & (nowDay==9):
    finder=1
  elif (nowMonth==12) & (nowDay==25):
    finder=1
  # 2021년 공휴일
  elif (nowYear==2021) & (nowMonth==2) & (nowDay==11):
    finder=1
  elif (nowYear==2021) & (nowMonth==2) & (nowDay==12):
    finder=1
  elif (nowYear==2021) & (nowMonth==2) & (nowDay==13):
    finder=1
  elif (nowYear==2021) & (nowMonth==5) & (nowDay==19):
    finder=1
  elif (nowYear==2021) & (nowMonth==9) & (nowDay==20):
    finder=1
  elif (nowYear==2021) & (nowMonth==9) & (nowDay==21):
    finder=1
  elif (nowYear==2021) & (nowMonth==9) & (nowDay==22):
    finder=1
  elif (nowYear==2021) & (nowMonth==6) & (nowDay==4): # 추후 삭제
    finder=1

"""**공휴일 대여소, 시간별 잔여 갯수 그래프: def numbike_graph_holiday()**"""

def numbike_graph_holiday():
  global borrow_location
  global bike_mean_bytime

  borrow_location = borrow_loc # =detailname[bike_stop-1] 사용자로부터 입력받은 정류소 이름

  # change_holiday_day() # 공통 공휴일 외 공휴일을 2021 기준으로 날짜 변경해줄 함수 호출 # 함수를 호출하려고 했는데 global로 지정 안했더니 반영 안되는 듯,, 
  # global로 지정하면 다음 코드에 문제 생길꺼같아서 함수로 만들지 않고 우선 그냥 코드 넣음 

  from pytz import timezone
  import datetime

  KST = timezone('Asia/Seoul')

  now = datetime.datetime.now(KST)

  # 날짜 구하기
  nowDate = now.date()

  # 년, 월, 일 구하기
  nowYear = now.year
  nowMonth = now.month
  nowDay = now.day

    # 2021년 공휴일
  if (nowYear==2021) & (nowMonth==2) & (nowDay==11):          # 2021년 설날일 경우
    nowMonth=1                                                # 2020년 설날 데이터 가져오기
    nowDay=24
  elif (nowYear==2021) & (nowMonth==2) & (nowDay==12):        # 2021년 설날일 경우
    nowMonth=1                                                # 2020년 설날 데이터 가져오기
    nowDay=25
  elif (nowYear==2021) & (nowMonth==2) & (nowDay==13):        # 2021년 설날일 경우
    nowMonth=1                                                # 2020년 설날 데이터 가져오기
    nowDay=26
  elif (nowYear==2021) & (nowMonth==5) & (nowDay==19):        # 2021년 부처님이오신날일 경우
    nowMonth=4                                                # 2020년 부처님이오신날 데이터 가져오기
    nowDay=30
  elif (nowYear==2021) & (nowMonth==9) & (nowDay==20):        # 2021년 추석일 경우
    nowMonth=9                                                # 2020년 추석 데이터 가져오기
    nowDay=30
  elif (nowYear==2021) & (nowMonth==9) & (nowDay==21):        # 2021년 추석일 경우
    nowMonth=10                                               # 2020년 추석 데이터 가져오기
    nowDay=1
  elif (nowYear==2021) & (nowMonth==9) & (nowDay==22):        # 2021년 추석일 경우
    nowMonth=10                                               # 2020년 추석 데이터 가져오기
    nowDay=2
  elif (nowYear==2021) & (nowMonth==6) & (nowDay==4):         # 추후 삭제
    nowMonth=1
    nowDay=24

  # 대여소명, 월, 일 동일 데이터 추출
  df_sameloc_minus = df_2020_processed[(df_2020_processed['대여 대여소명']==borrow_location)&(df_2020_processed['월(대여)']==nowMonth)&(df_2020_processed['일(대여)']==nowDay)]
  df_sameloc_plus = df_2020_processed[(df_2020_processed['반납대여소명']==borrow_location)&(df_2020_processed['월(반납)']==nowMonth)&(df_2020_processed['일(반납)']==nowDay)]

  # 초기 거치대 수(자전거 수)
  bike_initial = int(df_location_processed[df_location_processed['보관소(대여소)명'] == borrow_location]['총거치대수'])
  
  # 오전 7시, 오후 4시, 오후 11시 재배치 가정.
  # 현재 시간(시)와 '월', '일'이 같은 대여, 반납 개수
  time_h = [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,0,1,2,3,4,5,6] # 재배치 시간=0 으로 가정하여 시작
  bike_mean_bytime=[]
  # 공휴일은 월, 일 데이터가 같으므로 divider=1
  divider=1
  
  for time in time_h:
    if time == 7 or time == 16 or time == 23: # 오전 7시, 오후 4시, 오후 11시 재배치
       bike_initial = int(df_location_processed[df_location_processed['보관소(대여소)명'] == borrow_location]['총거치대수'])
    
    for minute in range(60): # '시', '분'이 같은 데이터 추출
      bike_b=len(df_sameloc_minus[(df_sameloc_minus['대여시']==time)&(df_sameloc_minus['대여분']==minute)])
      bike_l=len(df_sameloc_plus[(df_sameloc_plus['반납시']==time)&(df_sameloc_plus['반납분']==minute)])
      
      bike_b_m=bike_b/divider # 해당 대여소 대여 자전거 평균(단위: 분)
      bike_l_m=bike_l/divider # 해당 대여소 반납 자전거 평균(단위: 분)

      # (해당 대여소 잔여 자전거 평균) = (초기 거치대 수(자전거 수)) - (해당 대여소 대여 자전거 평균) + (해당 대여소 반납 자전거 평균)
      bike_total=bike_initial-bike_b_m+bike_l_m
      bike_mean_bytime.append(bike_total) # (해당 대여소 잔여 자전거 평균)값을 'bike_mean_bytime' list에 추가
      bike_initial = bike_total

  # 그래프 출력
  # x축: 시간(단위: 분, 오전 7시를 시작으로 함), y축: 해당 대여소 잔여 자전거 평균(단위: 개)
  plt.style.use('ggplot')
  plt.plot(bike_mean_bytime)
  plt.xlabel('현재 시각[오전 7시~]')
  plt.ylabel('따릉이 잔여 개수')
  plt.title(borrow_loc + ' 따릉이 잔여 개수')
  plt.show()

"""**요일별 대여소, 시간별 잔여 갯수 그래프: def numbike_graph()**

달별 요일 반복 횟수
*   2020년 1월 월-4 화-4 수-5 목-5 금-5 토-4 일-4
*   2020년 2월 월-4 화-4 수-4 목-4 금-4 토-5 일-4
*   2020년 3월 월-5 화-5 수-4 목-4 금-4 토-4 일-5
*   2020년 4월 월-4 화-4 수-5 목-5 금-4 토-4 일-4
*   2020년 5월 월-4 화-4 수-4 목-4 금-5 토-5 일-5
*   2020년 6월 월-5 화-5 수-4 목-4 금-4 토-4 일-4
*   2020년 7월 월-4 화-4 수-5 목-5 금-5 토-4 일-4
*   2020년 8월 월-5 화-4 수-4 목-4 금-4 토-5 일-5
*   2020년 9월 월-4 화-5 수-5 목-4 금-4 토-4 일-4
*   2020년 10월 월-4 화-4 수-4 목-5 금-5 토-5 일-4
*   2020년 11월 월-5 화-4 수-4 목-4 금-4 토-4 일-5
*   2020년 12월 월-4 화-5 수-5 목-5 금-4 토-4 일-4
"""

def numbike_graph():
  global borrow_location
  global bike_mean_bytime

  borrow_location = borrow_loc # =detailname[bike_stop-1] 사용자로부터 입력받은 정류소 이름
  
  # 대여소명, 요일, 월 동일 데이터 추출
  df_sameloc_minus = df_2020_processed[(df_2020_processed['대여 대여소명']==borrow_location)&(df_2020_processed['대여요일']==nowWeekday[0])&(df_2020_processed['월(대여)']==nowMonth)]
  df_sameloc_plus = df_2020_processed[(df_2020_processed['반납대여소명']==borrow_location)&(df_2020_processed['반납요일']==nowWeekday[0])&(df_2020_processed['월(반납)']==nowMonth)]

  # 요일 반복 횟수 구하기
  week_num=[[4,4,4,5,5,5,4,4],[4,4,4,4,4,5,4],[5,5,4,4,4,4,4,5],[4,4,5,5,4,4,4],[4,4,4,4,5,5,5],[5,5,4,4,4,4,4],[4,4,5,5,5,4,4],[5,4,4,4,4,5,5],[4,5,5,4,4,4,4],[4,4,4,5,5,5,4],[5,4,4,4,4,4,5],[4,5,5,5,4,4]]

  divider_list = week_num[nowMonth-1]

  if (nowWeekday[0] == "월"):
    divider = divider_list[0]
  elif (nowWeekday[0] == "화"):
    divider = divider_list[1]
  elif (nowWeekday[0] == "수"):
    divider = divider_list[2]
  elif (nowWeekday[0] == "목"):
    divider = divider_list[3]
  elif (nowWeekday[0] == "금"):
    divider = divider_list[4]
  elif (nowWeekday[0] == "토"):
    divider = divider_list[5]
  elif (nowWeekday[0] == "일"):
    divider = divider_list[6]
  print("divider:",divider)

  # 초기 거치대 수(자전거 수)
  bike_initial = int(df_location_processed[df_location_processed['보관소(대여소)명'] == borrow_location]['총거치대수'])
  
  # 오전 7시, 오후 4시, 오후 11시 재배치 가정.
  # 현재 시간(시)와 요일이 같은 대여, 반납 개수
  time_h = [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,0,1,2,3,4,5,6] # 재배치 시간=0 으로 가정하여 시작
  bike_mean_bytime=[]
  
  for time in time_h:
    if time == 7 or time == 16 or time == 23: # 오전 7시, 오후 4시, 오후 11시 재배치
       bike_initial = int(df_location_processed[df_location_processed['보관소(대여소)명'] == borrow_location]['총거치대수'])
    
    for minute in range(60): # '시', '분'이 같은 데이터 추출
      bike_b=len(df_sameloc_minus[(df_sameloc_minus['대여시']==time)&(df_sameloc_minus['대여분']==minute)])
      bike_l=len(df_sameloc_plus[(df_sameloc_plus['반납시']==time)&(df_sameloc_plus['반납분']==minute)])
      
      bike_b_m=bike_b/divider # 해당 대여소 대여 자전거 평균(단위: 분)
      bike_l_m=bike_l/divider # 해당 대여소 반납 자전거 평균(단위: 분)

      # (해당 대여소 잔여 자전거 평균) = (초기 거치대 수(자전거 수)) - (해당 대여소 대여 자전거 평균) + (해당 대여소 반납 자전거 평균)
      bike_total=bike_initial-bike_b_m+bike_l_m
      bike_mean_bytime.append(bike_total) # (해당 대여소 잔여 자전거 평균)값을 'bike_mean_bytime' list에 추가
      bike_initial = bike_total

  # 그래프 출력
  # x축: 시간(단위: 분, 오전 7시를 시작으로 함), y축: 해당 대여소 잔여 자전거 평균(단위: 개)
  plt.style.use('ggplot')
  plt.plot(bike_mean_bytime)
  plt.xlabel('현재 시각[오전 7시~]')
  plt.ylabel('따릉이 잔여 개수')
  plt.title(borrow_loc + ' 따릉이 잔여 개수')
  plt.show()

"""**궁금한 시간 입력받기: def num_anothertime()**"""

def num_anothertime(hour, minute):
  global know_minute
  
  # 궁금한 시간 잔여 개수 출력
  # 그래프 x축 시작점이 오전 7시라는 것을 감안
  if hour<7: # 사용자가 궁금한 시간이 오전 7시 이전일 경우
    know_minute=1440-(7*60-hour*60-minute)
  elif hour>=7: # 사용자가 궁금한 시간이 오전 7시 이후일 경우
    know_minute=hour*60+minute-7*60

  print(know_minute)
  print(bike_mean_bytime[know_minute]) # 사용자가 궁금한 시간대의 따릉이 잔여 개수를 'bike_mean_bytime' list에서 가져옴
  
  print(hour,"시",minute,"분",borrow_loc,"대여소의 자전거 잔여 개수:",bike_mean_bytime[know_minute])

"""**가까운 정류소 데이터셋 출력: def nearest_dataset()**"""

def nearest_dataset():
  global loca_around 
  global refer

  #정의된 bike_stop 인덱스값으로 기준 잡기
  refer=loca_gu['상세주소']==detailloca[bike_stop-1]
  refer2=loca_gu[refer]
  lati=refer2['위도']
  long=refer2['경도']
  latitude_1=float(lati)
  longitude_1=float(long)
  print(longitude_1,latitude_1)


  #사용자 입력 기준 여러 개의 상위 데이터 출력하기 (위도, 경도 +-0.004 둘다 만족)
  around_la_up=loca_gu['위도']-latitude_1<=0.004
  around_la_down=loca_gu['위도']-latitude_1>=-0.004
  around_lo_up=loca_gu['경도']-longitude_1<=0.004
  around_lo_down=loca_gu['경도']-longitude_1>=-0.004
  loca_around=loca_gu[(around_lo_up & around_lo_down) & (around_la_up & around_la_down)]
  loca_around

"""**가까운 정류소 지도 출력: def nearest_map()**"""

def nearest_map(): 
  global map_dt

  refer3=loca_gu['상세주소']==detailloca[bike_stop-1]
  refer4=loca_gu[refer]
  lati2=refer4['위도']
  long2=refer4['경도']
  latitude_2=float(lati2)
  longitude_2=float(long2)

  map_dt=folium.Map(location=[latitude_2,longitude_2], zoom_start = 19) 
  mc=MarkerCluster()
  names=list(loca_around['보관소(대여소)명'])
  latitudes=list(loca_around['위도'])
  longitudes=list(loca_around['경도'])

  for i in tqdm(range(len(names))):
    mc.add_child(folium.Marker(location = [latitudes[i], longitudes[i]], popup=names[i]))
    map_dt.add_child(mc)
  return map_dt

"""---

1. 선택한 정류소의 시간대(시간, 분)별 잔여 자전거 수 분포 그래프
2. 추가로 다른 시간의 정류소 상황이 궁금한 경우
3. 주변 정류장 추천

* 메인 코드
"""

# 사용자에게 구, 동, 길(로)를 입력받는다.
input_gudongro() # 예) 광진구, 자양동, 능동로

# 초기 지도를 출력한다.
initial_map()

# 사용자에게 정확한 대여소명을 입력받는다.
input_name()

# 해당 날짜가 공휴일인지 판단한다.
# finder 변수 지정 -> 공휴일이라면 finder=1, 공휴일이 아니라면 finder=0
find_holiday()

ans = input("\n 0. 종료 \n 1. 해당 대여소의 시간별 잔여 자전거수 분포 그래프 \n 2. 주변 정류장 추천 \n 원하는 기능의 번호를 입력하시오: ")
  
# 1. 해당 대여소의 시간별 잔여 자전거수 분포 그래프
if ans == "1":
  if finder == 1: # 공휴일인 경우
    numbike_graph_holiday()
  elif finder ==0:
    numbike_graph() # 공휴일이 아닌 경우
  # 사용자가 추가 정보를 받기 위해 입력한 0, 1, 2번 중 선택한 번호를 ans2에 저장한다.
  ans2 = input("\n 0. 종료 \n 1. 현재 시간의 잔여 자전거 수 \n 2. 다른 시간의 자전거 수 \n 원하는 기능의 번호를 입력하시오: ")

  # 1. 해당 대여소의 현재 시간의 잔여 자전거 수
  if ans2 == "1":
    hour = nowHour
    minute = nowMinute
    num_anothertime(hour,minute)
  # 2. 해당 대여소의 다른 시간의 자전거 수
  elif ans2 == "2":
    usertime=str(input("자전거 잔여 개수가 궁금한 시간을 입력하시오(예: 15:30) : "))
    usertime_1=usertime.split(':')
    hour=int(usertime_1[0])
    minute=int(usertime_1[1])
    num_anothertime(hour,minute)

# 2. 주변 정류장 추천
elif ans == "2":
  nearest_dataset()
  nearest_map()

# 가까운 대여소 출력
nearest_dataset()

# 가장 가까운 대여소 지도 출력
map_dt